$date
	Thu Oct  4 15:35:41 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module ALU $end
$var wire 1 ! carryout $end
$var wire 3 " command [2:0] $end
$var wire 32 # operandA [31:0] $end
$var wire 32 $ operandB [31:0] $end
$var wire 1 % overflow $end
$var wire 32 & result [31:0] $end
$var wire 1 ' zero $end
$upscope $end
$scope module ALU_last $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 3 * S [0:2] $end
$var wire 1 + carryin $end
$var wire 1 , zero $end
$var wire 1 - overflow $end
$var wire 1 . out $end
$var wire 1 / modB $end
$var wire 1 0 carryout $end
$var wire 1 1 as $end
$var wire 1 2 SLT $end
$var wire 8 3 I [0:7] $end
$scope module addsub $end
$var wire 1 ( A $end
$var wire 1 + carryin $end
$var wire 1 0 carryout $end
$var wire 1 4 out1 $end
$var wire 1 5 out2 $end
$var wire 1 6 out3 $end
$var wire 1 1 sum $end
$var wire 1 / B $end
$upscope $end
$scope module andgate $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 7 out $end
$upscope $end
$scope module elonMux $end
$var wire 8 8 I [7:0] $end
$var wire 3 9 S [2:0] $end
$var wire 1 . out $end
$upscope $end
$scope module nandgate $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 : out $end
$upscope $end
$scope module norgate $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 ; out $end
$upscope $end
$scope module orgate $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 < out $end
$upscope $end
$scope module xorgate $end
$var wire 1 ) A $end
$var wire 1 = B $end
$var wire 1 / out $end
$upscope $end
$scope module xorgate1 $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 > out $end
$upscope $end
$scope module xorgate2 $end
$var wire 1 + A $end
$var wire 1 0 B $end
$var wire 1 - out $end
$upscope $end
$scope module xorgate3 $end
$var wire 1 - A $end
$var wire 1 1 B $end
$var wire 1 2 out $end
$upscope $end
$upscope $end
$scope module add_sub_last $end
$var wire 1 ? A $end
$var wire 1 @ B $end
$var wire 1 A carryin $end
$var wire 1 B carryout $end
$var wire 1 C out1 $end
$var wire 1 D out2 $end
$var wire 1 E out3 $end
$var wire 1 F overflow $end
$var wire 1 G sum $end
$upscope $end
$scope module testAlu1bit $end
$var wire 1 H out $end
$var wire 1 I carryout $end
$var reg 1 J A $end
$var reg 1 K B $end
$var reg 3 L S [2:0] $end
$var reg 1 M carryin $end
$scope module alu $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 3 N S [0:2] $end
$var wire 1 M carryin $end
$var wire 1 H out $end
$var wire 1 O modB $end
$var wire 1 I carryout $end
$var wire 1 P addORsub $end
$var wire 8 Q I [7:0] $end
$scope module addsub $end
$var wire 1 J A $end
$var wire 1 M carryin $end
$var wire 1 I carryout $end
$var wire 1 R out1 $end
$var wire 1 S out2 $end
$var wire 1 T out3 $end
$var wire 1 P sum $end
$var wire 1 O B $end
$upscope $end
$scope module andgate $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 1 U out $end
$upscope $end
$scope module mux $end
$var wire 8 V I [7:0] $end
$var wire 3 W S [2:0] $end
$var wire 1 H out $end
$upscope $end
$scope module nandgate $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 1 X out $end
$upscope $end
$scope module norgate $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 1 Y out $end
$upscope $end
$scope module orgate $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 1 Z out $end
$upscope $end
$scope module xorgate $end
$var wire 1 K A $end
$var wire 1 [ B $end
$var wire 1 O out $end
$upscope $end
$scope module xorgate1 $end
$var wire 1 J A $end
$var wire 1 K B $end
$var wire 1 \ out $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
x\
0[
xZ
xY
xX
b0 W
bx0xxx V
xU
xT
xS
xR
bx0xxx Q
xP
xO
b0 N
0M
b0 L
1K
1J
xI
xH
xG
xF
xE
xD
xC
xB
zA
z@
z?
x>
z=
x<
x;
x:
bz 9
bx0xxxx 8
x7
x6
x5
x4
bx0xxxx 3
x2
x1
x0
x/
x.
x-
z,
z+
bz *
z)
z(
z'
bz &
z%
bz $
bz #
bz "
z!
$end
#10000
1O
bx00xx Q
bx00xx V
0\
#20000
0Y
bx00x00xx Q
bx00x00xx V
0X
#30000
1Z
b100100xx Q
b100100xx V
1U
0S
#40000
1T
0R
#70000
1I
0H
b10010000 Q
b10010000 V
0P
#10000000
